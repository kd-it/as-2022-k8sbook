# Deploymentリソース

デプロイメント(deployment)リソースは、Podを配下に従えて、Podの管理や更新・ロールバックなどをサポートします。
このリソースを考えるときには、直下に存在することになるレプリカセット(replicaset/rs)についてもおさえておく必要があります。

とりあえずdeploymentを作成して、そこからrsに下って学んでいくと良いでしょう。

## とりあえず作ってみる

vscodeのK8s拡張により、スニペットが用意されます。こちらを使ってみると良いでしょう。
なお、適用(`kubectl apply`)の前に、前の節で使っているPodリソース(1st/2nd)は消しておく方が良いでしょう。

```{figure} images/vscode-snippet-deploy.png
スニペット "deployment" の呼び出し
```

```{figure} images/vscode-snippet-deploy-result.png
呼び出し結果
```

呼び出されたスニペットをベースに、内容を書き換えていってください。

```{literalinclude} codes/deploy1.yml
:linenos:
:caption: スニペットをベースとしたnginxデプロイメント(強調部が変更しているところ)
:emphasize-lines: 4,8,12,15,16,22
```

まずはデプロイしてみましょう。様子をGUIで見たい方は、別途ダッシュボードを起動しておくと良いでしょう。

```{code-block} ps1
:caption: deploy1.ymlを用いたデプロイ

PS> kubectl apply -f deploy1.yml
deployment.apps/frontend created
```

ダッシュボード上で見た場合、1つのマニフェストですが、3つのワークロードが設定されています。

```{figure} images/dashboard-deploy1.png
ダッシュボード上の表示、3つのワークロードが出てきた
```

出てきたものは3つあります。

- デプロイメント(deployment)
- ポッド(pod)
- **レプリカセット**(replicaset)

このうちPodは前節で解説しているので、デプロイメントとレプリカセットを見ていきましょう。

## デプロイメントの定義

デプロイメントは、以下のAPIで定義されています。

- [Deployment v1 apps](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#deployment-v1-apps)
- apiVersion: apps/v1
- kind: Deployment

このマニフェストも、`metadata`の扱いは基本的に同じです。
spec部分が少しわかりにくいと思いますので、そこを見ていきましょう。

```{literalinclude} codes/deploy1.yml
:caption: deploy1.ymlのセレクタ部分(6〜8行目)
:lines: 6-8
```

セレクタ部(selector)は、**デプロイメントが管理対象とするPodの選択方法**を指示するために使うものとなっています。
ここでは**特定のラベルが付与されている**(`matchlabels`)ことを条件としており、該当するラベルのKey-Valueを辞書として記述しています。
今回のケースであれば、`app`キーに対する値`frontend`が付与されたものということになります。

そのうえで、起動させたいポッドの定義を `template`以下に記載します。
この部分は、実はポッドの定義と同じになっています。

```{literalinclude} codes/deploy1.yml
:caption: deploy1.ymlのPod定義テンプレート(9〜22行目)
:lines: 9-22
:emphasize-lines: 3-4
```

このテンプレート部分で、メタデータとしてラベル(`app`が`frontend`)としているため、起動したPodにはそのラベルが付加され、それをデプロイメントが見つけて管理するということになるのです。
冗長さを感じるかもしれませんが、テンプレート側とセレクタ側で「ひっかける」ための条件をきちんと同じになるよう設定しましょう。
もちろんこの方法以外のセレクタ設定は存在しますが、今は概念として**セレクタを条件として合致するポッドをハイかとする**というルールを意識しておけば十分です。

## レプリカセット

続いてレプリカセットです。実はデプロイメントはあくまでセレクタでひっかけたポッドを見張るにすぎません。
ポッドの増減自体を管理するのは、こちらのレプリカセットとなります。
レプリカセットは、テンプレートで設定されたポッドが指定された数だけ存在するかを管理し、何らかの要因でポッドが減った場合には新たにポッドを生成しますし、要求数が減ったときに適当にポッドを間引きます。

実はデプロイメントで書いていたPodテンプレートはこのレプリカセットが利用するためのものだったりします。
関係性をツリー状にすれば、ざっくりこのようなかたちです。

```{figure} images/deployment.drawio.png
デプロイ・レプリカセット・ポッドの関係図(レプリカ数3での例)
```

## レプリケーション(スケーリング)

ダッシュボードを使ったデプロイメントを試した際に、スケーリングを試しましたが、マニフェスト上でも可能です。
実際の所はスケーリングの値(いくつ同じ内容のPodを生成するか)です。

実際にスケーリングのパラメータを追加してみます。記述する位置が、セレクタ指示などと同じ階層なので注意してください。

```{literalinclude} codes/deploy1-replica2.yml
:caption: レプリカ数2に設定
:name: deploy1.yml
:lines: 1-10
:emphasize-lines: 6
```

これを再適用(`kubectl apply -f deploy1.yml`)すると、ポッド数が2になります。

```{code-block} ps1
PS> kubectl apply -f deploy1.yml
deployment.apps/frontend configured
```

```{figure} images/deployment-replica2.png
レプリカ数2に設定したときのダッシュボード(ポッドが増えている)
```

どうしてこんなことをする必要があるかですが、いわゆる**スケールアウト**を実現するためのものです。
1つのサーバーでは、同時に引き受けられるのは実際1つだけです(すごいスピードで処理しているから並列で処理しているように見えますが違います)。
だったら複数のサーバーを待ち受けにして、両方で仕事できればいいよねというかなり安直な考え方だったりします。

こうやって複数のポッドが閉口して動けるようになっているのですが、ポッドそのものはテンプレートから生成されているため、どちらも同じラベルを持つことになります。そのためデプロイメントは複数のポッドを検出するようになり、配下として管理するわけですね。

```{caution}
ちょっと待って!  **誰が2つに分かれたサーバーにリクエストを分配するの?**
となると思います。この部分については今は横に置いておきましょう(モヤッとしますが)。
```

